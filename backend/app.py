"""
·ª®ng d·ª•ng backend ch√≠nh - ƒê√É S·ª¨A L·ªñI HO√ÄN CH·ªàNH
X·ª≠ l√Ω c√°c API endpoints v√† ƒëi·ªÅu ph·ªëi d·ªãch v·ª•
"""
from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
import os
import json
import time
import base64
import cv2
import numpy as np
from ultralytics import YOLO
import google.generativeai as genai
from text_to_speech import TextToSpeechService
from speech_to_text import SpeechToTextService

app = Flask(__name__)
CORS(app)  # B·∫≠t CORS ƒë·ªÉ frontend c√≥ th·ªÉ giao ti·∫øp

# Kh·ªüi t·∫°o c√°c d·ªãch v·ª•
print("üîß ƒêang kh·ªüi t·∫°o c√°c d·ªãch v·ª• ƒë∆∞·ª£c t·ªëi ∆∞u h√≥a...")
tts_service = TextToSpeechService()
stt_service = SpeechToTextService()

# Kh·ªüi t·∫°o Gemini AI v√† YOLO cho gesture detection
genai.configure(api_key="AIzaSyC7ibsJvR85BLS14ozgyvOTjHOehHemPWA")
generation_config = {
    "temperature": 1,
    "top_p": 0.95,
    "top_k": 40,
    "max_output_tokens": 8192,
}
model = genai.GenerativeModel(
    model_name="gemini-2.0-flash",  # S·ª≠ d·ª•ng model m·ªõi nh·∫•t
    generation_config=generation_config,
)

# Dictionary ƒë·ªÉ l∆∞u tr·ªØ t·ª´ kh√≥a ph√°t hi·ªán ƒë∆∞·ª£c
detected_words = []

# Bi·∫øn theo d√µi c·ª≠ ch·ªâ hi·ªán t·∫°i v√† th·ªùi gian gi·ªØ
last_gesture = None
gesture_start_time = None
hold_time_threshold = 0.6  # gi√¢y c·∫ßn gi·ªØ ƒë·ªÉ x√°c nh·∫≠n c·ª≠ ch·ªâ (gi·ªëng nh∆∞ trong api.py)

# Mock YOLO model initialization (fallback approach)
class MockYOLOModel:
    def __init__(self):
        self.names = {
            0: 'bread', 1: 'like', 2: 'home', 3: 'you', 4: 'i', 
            5: 'listen', 6: 'sleep', 7: 'go', 8: 'drink', 9: 'no',
            10: 'yes', 11: 'love', 12: 'goodbye', 13: 'thank', 14: 'hello',
            15: 'eat', 16: 'read'
        }
        
    def predict(self, source, save=False):
        # Mock prediction result
        import random
        import time
        
        # Simulate some processing time
        time.sleep(0.1)
        
        # Return mock result with random word detection
        mock_result = type('MockResult', (), {
            'boxes': type('MockBoxes', (), {
                'cls': [random.randint(0, 16)] if random.random() > 0.3 else [],
                'conf': [0.8] if random.random() > 0.3 else []
            })()
        })()
        
        return [mock_result]

try:
    print("ü§ñ ƒêang t·∫£i YOLO model...")
    yolo_model = YOLO('D:/project_aidev/backend/best.pt')  # S·ª≠a ƒë∆∞·ªùng d·∫´n ƒë·ªÉ t√¨m file best.pt
    print("‚úÖ YOLO model ƒë√£ ƒë∆∞·ª£c t·∫£i th√†nh c√¥ng!")
except Exception as e:
    print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫£i YOLO model: {e}")
    print("üîÑ S·ª≠ d·ª•ng Mock model ƒë·ªÉ demo...")
    yolo_model = MockYOLOModel()

@app.route('/', methods=['GET'])
def home():
    """Endpoint ki·ªÉm tra s·ª©c kh·ªèe h·ªá th·ªëng"""
    return jsonify({
        "status": "running",
        "message": "Sign Language Backend API - ƒê√É S·ª¨A L·ªñI HO√ÄN CH·ªàNH",
        "version": "1.3.0",
        "available_engines": {
            "tts": tts_service.get_available_engines(),
            "stt": stt_service.get_available_engines()
        },
        "voice_samples": tts_service.get_voice_samples()
    })



@app.route('/api/text-to-speech', methods=['POST'])
def text_to_speech():
    """Chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i v·ªõi l·ª±a ch·ªçn gi·ªçng t·ªëi ∆∞u v√† ElevenLabs"""
    try:
        data = request.get_json()
        
        if not data or 'text' not in data:
            return jsonify({"success": False, "error": "C·∫ßn c√≥ vƒÉn b·∫£n ƒë·ªÉ chuy·ªÉn ƒë·ªïi"}), 400
        
        text = data['text']
        language = data.get('language', 'vi')
        voice = data.get('voice', 'female')
        voice_id = data.get('voice_id')  # ElevenLabs voice ID
        
        print(f"üîä Y√™u c·∫ßu TTS: text='{text[:50]}...', ng√¥n ng·ªØ={language}, gi·ªçng={voice}, voice_id={voice_id}")
        
        result = tts_service.convert_text_to_speech(text, language, voice, voice_id)
        
        print(f"‚úÖ TTS th√†nh c√¥ng: engine {result.get('engine', 'unknown')}, gi·ªçng: {result.get('voice_name', 'unknown')}")
        return jsonify(result)
        
    except Exception as e:
        print(f"‚ùå L·ªói TTS: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/speech-to-text', methods=['POST'])
def speech_to_text():
    """Chuy·ªÉn gi·ªçng n√≥i th√†nh vƒÉn b·∫£n"""
    try:
        # X·ª≠ l√Ω upload file
        if 'audio' not in request.files:
            return jsonify({"success": False, "error": "C·∫ßn c√≥ file √¢m thanh"}), 400
        
        audio_file = request.files['audio']
        language = request.form.get('language', 'vi')
        
        if audio_file.filename == '':
            return jsonify({"success": False, "error": "Ch∆∞a ch·ªçn file"}), 400
        
        print(f"üé§ Y√™u c·∫ßu STT: file={audio_file.filename}, ng√¥n ng·ªØ={language}")
        
        # L∆∞u file upload t·∫°m th·ªùi
        temp_path = os.path.join("temp", audio_file.filename)
        os.makedirs("temp", exist_ok=True)
        audio_file.save(temp_path)
        
        # X·ª≠ l√Ω √¢m thanh
        result = stt_service.convert_speech_to_text(temp_path, language)
        
        # D·ªçn d·∫πp file t·∫°m
        if os.path.exists(temp_path):
            os.remove(temp_path)
        
        print(f"‚úÖ STT th√†nh c√¥ng: engine {result.get('engine', 'unknown')} ƒë√£ s·ª≠ d·ª•ng")
        return jsonify(result)
        
    except Exception as e:
        print(f"‚ùå L·ªói STT: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/start-recording', methods=['POST'])
def start_recording():
    """B·∫Øt ƒë·∫ßu ghi √¢m"""
    try:
        result = stt_service.start_recording()
        print(f"üé§ B·∫Øt ƒë·∫ßu ghi √¢m: {result.get('session_id')}")
        return jsonify(result)
    except Exception as e:
        print(f"‚ùå L·ªói b·∫Øt ƒë·∫ßu ghi √¢m: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/stop-recording', methods=['POST'])
def stop_recording():
    """D·ª´ng ghi √¢m"""
    try:
        data = request.get_json()
        session_id = data.get('session_id')
        
        if not session_id:
            return jsonify({"success": False, "error": "C·∫ßn c√≥ Session ID"}), 400
        
        result = stt_service.stop_recording(session_id)
        print(f"üé§ D·ª´ng ghi √¢m: {session_id}")
        return jsonify(result)
        
    except Exception as e:
        print(f"‚ùå L·ªói d·ª´ng ghi √¢m: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/download-audio/<filename>', methods=['GET'])
def download_audio(filename):
    """T·∫£i xu·ªëng file √¢m thanh ƒë√£ t·∫°o"""
    try:
        file_path = os.path.join("audio_output", filename)
        if os.path.exists(file_path):
            print(f"üì• T·∫£i xu·ªëng √¢m thanh: {filename}")
            # Th√™m CORS headers v√† content type cho audio
            response = send_file(file_path, mimetype='audio/mpeg')
            response.headers['Access-Control-Allow-Origin'] = '*'
            response.headers['Access-Control-Allow-Methods'] = 'GET, OPTIONS'
            response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
            return response
        else:
            return jsonify({"success": False, "error": "Kh√¥ng t√¨m th·∫•y file"}), 404
    except Exception as e:
        print(f"‚ùå L·ªói t·∫£i xu·ªëng: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/play-audio/<filename>', methods=['GET'])
def play_audio(filename):
    """Ph√°t file √¢m thanh tr·ª±c ti·∫øp (cho audio player)"""
    try:
        file_path = os.path.join("audio_output", filename)
        if os.path.exists(file_path):
            print(f"üéµ Ph√°t √¢m thanh: {filename}")
            # Tr·∫£ v·ªÅ file √¢m thanh v·ªõi headers ph√π h·ª£p cho audio player
            response = send_file(
                file_path, 
                mimetype='audio/mpeg',
                conditional=True  # H·ªó tr·ª£ range requests
            )
            response.headers['Access-Control-Allow-Origin'] = '*'
            response.headers['Access-Control-Allow-Methods'] = 'GET, HEAD, OPTIONS'
            response.headers['Access-Control-Allow-Headers'] = 'Range, Content-Type'
            response.headers['Accept-Ranges'] = 'bytes'
            return response
        else:
            return jsonify({"success": False, "error": "Kh√¥ng t√¨m th·∫•y file"}), 404
    except Exception as e:
        print(f"‚ùå L·ªói ph√°t √¢m thanh: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/languages', methods=['GET'])
def get_languages():
    """L·∫•y danh s√°ch ng√¥n ng·ªØ ƒë∆∞·ª£c h·ªó tr·ª£ v·ªõi m√¥ t·∫£"""
    return jsonify({
        "success": True,
        "tts_languages": tts_service.get_supported_languages(),
        "stt_languages": stt_service.get_supported_languages()
    })

@app.route('/api/voices', methods=['GET'])
def get_voices():
    """L·∫•y danh s√°ch gi·ªçng n√≥i ƒë∆∞·ª£c h·ªó tr·ª£ cho TTS v·ªõi m√¥ t·∫£"""
    return jsonify({
        "success": True,
        "voices": tts_service.get_supported_voices(),
        "voice_samples": tts_service.get_voice_samples()
    })

@app.route('/api/engines', methods=['GET'])
def get_engines():
    """L·∫•y tr·∫°ng th√°i c√°c engines c√≥ s·∫µn"""
    return jsonify({
        "success": True,
        "tts_engines": tts_service.get_available_engines(),
        "stt_engines": stt_service.get_available_engines()
    })

@app.route('/api/test-voice', methods=['POST'])
def test_voice():
    """Test gi·ªçng n√≥i v·ªõi vƒÉn b·∫£n m·∫´u"""
    try:
        data = request.get_json()
        language = data.get('language', 'vi')
        voice = data.get('voice', 'female')
        
        # L·∫•y vƒÉn b·∫£n m·∫´u cho ng√¥n ng·ªØ
        voice_samples = tts_service.get_voice_samples()
        sample_text = voice_samples.get(language, {}).get('sample_text', 'Xin ch√†o, ƒë√¢y l√† test gi·ªçng n√≥i.')
        
        print(f"üéµ Test gi·ªçng n√≥i: ng√¥n ng·ªØ={language}, gi·ªçng={voice}")
        
        result = tts_service.convert_text_to_speech(sample_text, language, voice)
        
        print(f"‚úÖ Test gi·ªçng n√≥i th√†nh c√¥ng: {result.get('voice_name', 'unknown')}")
        return jsonify(result)
        
    except Exception as e:
        print(f"‚ùå L·ªói test gi·ªçng n√≥i: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/voice-options', methods=['GET'])
def get_voice_options():
    """L·∫•y danh s√°ch t√πy ch·ªçn gi·ªçng n√≥i chi ti·∫øt cho ElevenLabs - ƒê√É S·ª¨A L·ªñI HO√ÄN CH·ªàNH"""
    try:
        language = request.args.get('language', 'vi')  # ‚Üê ƒê√É S·ª¨A: L·∫•y ng√¥n ng·ªØ t·ª´ query parameter
        print(f"üéµ API nh·∫≠n language: {language}")
        voice_options = tts_service.get_voice_options(language)  # ‚Üê ƒê√É S·ª¨A: Truy·ªÅn parameter language
        print(f"‚úÖ Tr·∫£ v·ªÅ voice options cho {language}: {len(voice_options.get('female_voices', []))} n·ªØ, {len(voice_options.get('male_voices', []))} nam")
        
        # Debug: In ra danh s√°ch gi·ªçng n√≥i chi ti·∫øt
        if language == 'vi':
            print("üáªüá≥ Gi·ªçng ti·∫øng Vi·ªát:")
            for voice in voice_options.get('female_voices', []):
                print(f"   N·ªØ: {voice.get('name')} - {voice.get('voice_id')}")
            for voice in voice_options.get('male_voices', []):
                print(f"   Nam: {voice.get('name')} - {voice.get('voice_id')}")
        elif language == 'en':
            print("üá∫üá∏ Gi·ªçng ti·∫øng Anh:")
            for voice in voice_options.get('female_voices', []):
                print(f"   N·ªØ: {voice.get('name')} - {voice.get('voice_id')}")
            for voice in voice_options.get('male_voices', []):
                print(f"   Nam: {voice.get('name')} - {voice.get('voice_id')}")
        
        return jsonify({
            "success": True,
            "voice_options": voice_options
        })
    except Exception as e:
        print(f"‚ùå L·ªói l·∫•y voice options: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/voice-info/<voice_id>', methods=['GET'])
def get_voice_info(voice_id):
    """L·∫•y th√¥ng tin chi ti·∫øt c·ªßa m·ªôt gi·ªçng n√≥i theo voice_id"""
    try:
        voice_info = tts_service.get_voice_by_id(voice_id)
        if voice_info:
            return jsonify({
                "success": True,
                "voice_info": voice_info
            })
        else:
            return jsonify({
                "success": False,
                "error": "Kh√¥ng t√¨m th·∫•y gi·ªçng n√≥i v·ªõi ID n√†y"
            }), 404
    except Exception as e:
        print(f"‚ùå L·ªói l·∫•y voice info: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/test-voice-by-id', methods=['POST'])
def test_voice_by_id():
    """Test gi·ªçng n√≥i c·ª• th·ªÉ b·∫±ng voice_id"""
    try:
        data = request.get_json()
        voice_id = data.get('voice_id')
        language = data.get('language', 'vi')
        
        if not voice_id:
            return jsonify({"success": False, "error": "C·∫ßn c√≥ voice_id"}), 400
        
        # L·∫•y th√¥ng tin gi·ªçng n√≥i
        voice_info = tts_service.get_voice_by_id(voice_id)
        if not voice_info:
            return jsonify({"success": False, "error": "Voice ID kh√¥ng h·ª£p l·ªá"}), 400
        
        # L·∫•y vƒÉn b·∫£n m·∫´u cho ng√¥n ng·ªØ
        voice_samples = tts_service.get_voice_samples()
        sample_text = voice_samples.get(language, {}).get('sample_text', 'Xin ch√†o, ƒë√¢y l√† test gi·ªçng n√≥i.')
        
        print(f"üéµ Test gi·ªçng n√≥i b·∫±ng ID: voice_id={voice_id}, ng√¥n ng·ªØ={language}")
        
        result = tts_service.convert_text_to_speech(sample_text, language, voice_info['gender'], voice_id)
        
        print(f"‚úÖ Test gi·ªçng n√≥i th√†nh c√¥ng: {result.get('voice_name', 'unknown')}")
        return jsonify(result)
        
    except Exception as e:
        print(f"‚ùå L·ªói test gi·ªçng n√≥i b·∫±ng ID: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/health', methods=['GET'])
def health_check():
    """Ki·ªÉm tra s·ª©c kh·ªèe chi ti·∫øt c·ªßa h·ªá th·ªëng"""
    try:
        # Ki·ªÉm tra c√°c th∆∞ m·ª•c c·∫ßn thi·∫øt
        directories = ["audio_output", "recordings", "temp"]
        dir_status = {}
        
        for directory in directories:
            dir_status[directory] = {
                "exists": os.path.exists(directory),
                "writable": os.access(directory, os.W_OK) if os.path.exists(directory) else False
            }
        
        # Ki·ªÉm tra bi·∫øn m√¥i tr∆∞·ªùng
        env_status = {
            "ELEVENLABS_API_KEY": bool(os.getenv('ELEVENLABS_API_KEY')),
            "GOOGLE_API_KEY": bool(os.getenv('GOOGLE_API_KEY')),
            "GOOGLE_APPLICATION_CREDENTIALS": bool(os.getenv('GOOGLE_APPLICATION_CREDENTIALS')),
            "TTS_ENGINE": os.getenv('TTS_ENGINE', 'auto'),
            "STT_ENGINE": os.getenv('STT_ENGINE', 'auto')
        }
        
        return jsonify({
            "success": True,
            "status": "healthy",
            "directories": dir_status,
            "environment": env_status,
            "engines": {
                "tts": tts_service.get_available_engines(),
                "stt": stt_service.get_available_engines()
            }
        })
        
    except Exception as e:
        return jsonify({
            "success": False,
            "status": "unhealthy",
            "error": str(e)
        }), 500

# ===== GESTURE DETECTION ENDPOINTS =====

@app.route('/api/gesture-detect', methods=['POST'])
def gesture_detect():
    """Ph√°t hi·ªán k√Ω hi·ªáu t·ª´ h√¨nh ·∫£nh camera v·ªõi c∆° ch·∫ø gi·ªØ ·ªïn ƒë·ªãnh - c·∫£i ti·∫øn theo api.py"""
    global last_gesture, gesture_start_time, detected_words
    
    try:
        data = request.get_json()
        
        if not data or 'image' not in data:
            return jsonify({"success": False, "error": "C·∫ßn c√≥ h√¨nh ·∫£nh ƒë·ªÉ ph√°t hi·ªán"}), 400
        
        # Decode base64 image
        image_data = data['image'].split(',')[1]  # Remove data:image/jpeg;base64,
        image_bytes = base64.b64decode(image_data)
        
        # Convert to OpenCV image
        nparr = np.frombuffer(image_bytes, np.uint8)
        frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
        
        if frame is None:
            return jsonify({"success": False, "error": "Kh√¥ng th·ªÉ decode h√¨nh ·∫£nh"}), 400
        
        # Run YOLO detection
        results = yolo_model.predict(frame, save=False, conf=0.5, iou=0.45)
        
        detected_word = None
        confidence = 0
        is_word_confirmed = False
        hold_time = 0
        
        # Logic ph√°t hi·ªán ·ªïn ƒë·ªãnh h∆°n, gi·ªëng trong api.py
        if results and len(results) > 0:
            boxes = results[0].boxes
            if boxes is not None and len(boxes.cls) > 0:
                if hasattr(boxes, 'conf') and len(boxes.conf) > 0:
                    # L·∫•y l·ªõp v·ªõi ƒë·ªô tin c·∫≠y cao nh·∫•t
                    conf_values = boxes.conf.cpu().numpy()
                    max_conf_idx = np.argmax(conf_values)
                    confidence = float(conf_values[max_conf_idx])
                    class_id = int(boxes.cls[max_conf_idx].cpu().numpy())
                    
                    if hasattr(yolo_model, 'names') and class_id in yolo_model.names:
                        current_gesture = yolo_model.names[class_id]
                        
                        # X·ª≠ l√Ω theo d√µi th·ªùi gian gi·ªØ c·ª≠ ch·ªâ (gi·ªëng api.py)
                        if current_gesture != last_gesture:
                            last_gesture = current_gesture
                            gesture_start_time = time.time()
                            hold_time = 0
                            is_word_confirmed = False
                        else:
                            if gesture_start_time is not None:
                                hold_time = time.time() - gesture_start_time
                                
                                # N·∫øu gi·ªØ ƒë·ªß l√¢u v√† ch∆∞a ƒë∆∞·ª£c th√™m v√†o danh s√°ch
                                if hold_time >= hold_time_threshold:
                                    is_word_confirmed = True
                                    detected_word = current_gesture
                                    
                                    # Ki·ªÉm tra ƒë∆°n gi·∫£n: ch·ªâ th√™m n·∫øu kh√°c t·ª´ cu·ªëi c√πng ho·∫∑c ch∆∞a c√≥ t·ª´ n√†o
                                    if len(detected_words) == 0 or detected_words[-1]['word'] != current_gesture:
                                        detected_words.append({
                                            'word': current_gesture,
                                            'confidence': confidence,
                                            'timestamp': time.time()
                                        })
                                        print(f"‚úÖ ƒê√£ ph√°t hi·ªán t·ª´ m·ªõi: {current_gesture} (confidence: {confidence:.2f})")
        else:
            # Reset n·∫øu kh√¥ng ph√°t hi·ªán g√¨
            last_gesture = None
            gesture_start_time = None
            
        return jsonify({
            "success": True,
            "detected_word": last_gesture,
            "confirmed_word": detected_word if is_word_confirmed else None,
            "confidence": confidence, 
            "hold_time": hold_time,
            "is_confirmed": is_word_confirmed,
            "total_words": len(detected_words),
            "words": [w['word'] for w in detected_words]
        })
        
    except Exception as e:
        print(f"‚ùå L·ªói gesture detection: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/gesture-add-word', methods=['POST'])
def gesture_add_word():
    """Th√™m t·ª´ ƒë∆∞·ª£c ph√°t hi·ªán v√†o danh s√°ch"""
    try:
        data = request.get_json()
        
        if not data or 'word' not in data:
            return jsonify({"success": False, "error": "C·∫ßn c√≥ t·ª´ ƒë·ªÉ th√™m"}), 400
        
        word = data['word']
        confidence = data.get('confidence', 0)
        
        # Th√™m t·ª´ v√†o danh s√°ch
        detected_words.append({
            'word': word,
            'confidence': confidence,
            'timestamp': __import__('time').time()
        })
        
        print(f"‚ûï ƒê√£ th√™m t·ª´: {word} (confidence: {confidence:.2f})")
        
        return jsonify({
            "success": True,
            "message": f"ƒê√£ th√™m t·ª´: {word}",
            "total_words": len(detected_words),
            "words": [w['word'] for w in detected_words]
        })
        
    except Exception as e:
        print(f"‚ùå L·ªói th√™m t·ª´: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/gesture-get-words', methods=['GET'])
def gesture_get_words():
    """L·∫•y danh s√°ch t·ª´ ƒë√£ ph√°t hi·ªán"""
    try:
        return jsonify({
            "success": True,
            "words": [w['word'] for w in detected_words],
            "detailed_words": detected_words,
            "total_words": len(detected_words)
        })
        
    except Exception as e:
        print(f"‚ùå L·ªói l·∫•y danh s√°ch t·ª´: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/gesture-generate-sentence', methods=['POST'])
def gesture_generate_sentence():
    """T·∫°o c√¢u t·ª´ danh s√°ch t·ª´ ƒë√£ ph√°t hi·ªán b·∫±ng Gemini AI"""
    try:
        if not detected_words:
            return jsonify({"success": False, "error": "Ch∆∞a c√≥ t·ª´ n√†o ƒë∆∞·ª£c ph√°t hi·ªán"}), 400
        
        # L·∫•y danh s√°ch t·ª´
        words = [w['word'] for w in detected_words]
        words_str = ', '.join(words)
        
        # T·∫°o prompt c·∫£i ti·∫øn ƒë·ªÉ gi·ªØ nguy√™n th·ª© t·ª± c√°c t·ª´, ƒë·∫£m b·∫£o c√¢u ho√†n to√†n ti·∫øng Anh v√† s√°t nghƒ©a
        prompt = f"""
        From the following list of words (in chronological detection order): {words}
        
        Your task is to create ONE simple, concise, and contextually appropriate English sentence with the following MANDATORY requirements:
        
        1. You MUST use all words from the list in their exact form
        2. You MUST MAINTAIN the exact order of appearance of the words in the resulting sentence, from beginning to end (this is the MOST IMPORTANT)
        3. Add ONLY ESSENTIAL connecting words (if needed) between the given words to form a grammatically correct sentence
        4. Keep the sentence as SIMPLE as possible - prefer adding fewer words rather than more
        5. DO NOT add extra adjectives, adverbs, or descriptive phrases that change the core meaning
        6. Return ONLY the resulting sentence, without any explanation or additional content
        7. The sentence MUST be ENTIRELY in English, with NO Vietnamese words or phrases mixed in
        8. The meaning of the sentence should closely reflect the likely intent of the detected words
        
        Example 1: If the word list is [i, love, you], the resulting sentence should simply be "I love you."
        Example 2: If the word list is [eat, bread, go, home], the resulting sentence should be "I eat bread and go home."
        """
        
        # G·ªçi Gemini API
        response = model.generate_content(prompt)
        generated_sentence = response.text.strip()
        
        print(f"ü§ñ C√¢u ƒë∆∞·ª£c t·∫°o: {generated_sentence}")
        print(f"üìù T·ª´ c√°c t·ª´: {words_str}")
        
        return jsonify({
            "success": True,
            "sentence": generated_sentence,
            "words_used": words,
            "total_words": len(detected_words)
        })
        
    except Exception as e:
        print(f"‚ùå L·ªói t·∫°o c√¢u: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

@app.route('/api/gesture-clear-words', methods=['POST'])
def gesture_clear_words():
    """X√≥a danh s√°ch t·ª´ ƒë√£ ph√°t hi·ªán"""
    try:
        global detected_words
        detected_words = []
        
        print("üóëÔ∏è ƒê√£ x√≥a danh s√°ch t·ª´")
        
        return jsonify({
            "success": True,
            "message": "ƒê√£ x√≥a danh s√°ch t·ª´",
            "total_words": 0
        })
        
    except Exception as e:
        print(f"‚ùå L·ªói x√≥a danh s√°ch t·ª´: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

if __name__ == '__main__':
    # T·∫°o c√°c th∆∞ m·ª•c c·∫ßn thi·∫øt
    os.makedirs("audio_output", exist_ok=True)
    os.makedirs("recordings", exist_ok=True)
    os.makedirs("temp", exist_ok=True)
    
    print("üöÄ ƒêang kh·ªüi ƒë·ªông Sign Language Backend API - ƒê√É S·ª¨A L·ªñI HO√ÄN CH·ªàNH...")
    print("üì° API s·∫Ω c√≥ s·∫µn t·∫°i: http://localhost:5000")
    print("üìã C√°c endpoints c√≥ s·∫µn:")
    print("  - GET  /                     - Ki·ªÉm tra s·ª©c kh·ªèe h·ªá th·ªëng")
    print("  - POST /api/text-to-speech   - Chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i")
    print("  - POST /api/speech-to-text   - Chuy·ªÉn gi·ªçng n√≥i th√†nh vƒÉn b·∫£n")
    print("  - POST /api/start-recording  - B·∫Øt ƒë·∫ßu ghi √¢m")
    print("  - POST /api/stop-recording   - D·ª´ng ghi √¢m")
    print("  - GET  /api/languages        - L·∫•y ng√¥n ng·ªØ ƒë∆∞·ª£c h·ªó tr·ª£")
    print("  - GET  /api/voices           - L·∫•y gi·ªçng n√≥i ƒë∆∞·ª£c h·ªó tr·ª£")
    print("  - GET  /api/engines          - L·∫•y tr·∫°ng th√°i engines")
    print("  - POST /api/test-voice       - Test gi·ªçng n√≥i v·ªõi m·∫´u")
    print("  - GET  /api/health           - Ki·ªÉm tra s·ª©c kh·ªèe chi ti·∫øt")
    print("  - GET  /api/download-audio/<filename> - T·∫£i xu·ªëng file √¢m thanh")
    print("  - POST /api/gesture-detect   - Ph√°t hi·ªán k√Ω hi·ªáu t·ª´ h√¨nh ·∫£nh")
    print("  - POST /api/gesture-add-word - Th√™m t·ª´ ƒë∆∞·ª£c ph√°t hi·ªán")
    print("  - GET  /api/gesture-get-words - L·∫•y danh s√°ch t·ª´ ƒë√£ ph√°t hi·ªán")
    print("  - POST /api/gesture-generate-sentence - T·∫°o c√¢u t·ª´ c√°c t·ª´")
    print("  - POST /api/gesture-clear-words - X√≥a danh s√°ch t·ª´")
    
    print("\nüîß Tr·∫°ng th√°i Engine:")
    print("TTS Engines:", tts_service.get_available_engines())
    print("STT Engines:", stt_service.get_available_engines())
    
    print("\nüéµ M·∫´u gi·ªçng n√≥i:")
    voice_samples = tts_service.get_voice_samples()
    for lang, samples in voice_samples.items():
        print(f"  {lang}: {samples['sample_text'][:50]}...")
    
    print("\n‚úÖ H·ªá th·ªëng ƒë√£ s·∫µn s√†ng!")
    app.run(debug=True, host='0.0.0.0', port=5000)